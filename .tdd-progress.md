# TDD Progress: Harden Hook Scripts — Retroactive Test Coverage + JSON Output Safety Fix

**Created:** 2026-02-15
**Status:** In Progress

---

## Feature Description

Three hook scripts need hardening: `check-tdd-progress.sh` has zero test coverage;
`auto-run-tests.sh` has a JSON output safety bug on line 64 and is missing FVM/dart/C++ path tests;
`validate-tdd-order.sh` is missing edge case coverage for `.cc`, `.hpp`, `test_` prefix, and malformed JSON.

---

## Requirements

### Functional Requirements
- [ ] `check-tdd-progress.sh` has complete test coverage for all 5 code paths
- [ ] `auto-run-tests.sh` JSON output is always valid JSON (safety fix using `jq`)
- [ ] `auto-run-tests.sh` FVM detection path is tested in 3 scenarios
- [ ] `auto-run-tests.sh` dart file mapping and C++ build detection are tested
- [ ] `validate-tdd-order.sh` edge cases are tested (`.cc`, `_test.cc`, `_test.hpp`, empty path, malformed JSON, git failure, `test_` prefix)

### Non-Functional Requirements
- [ ] All scripts pass `shellcheck -S warning`
- [ ] All existing 67 tests continue to pass (no regressions)
- [ ] Test patterns match established conventions (helpers, naming, cleanup)

---

## Slice 1: check-tdd-progress.sh — Retroactive Test Coverage

**Status:** done

**Source:** `hooks/check-tdd-progress.sh`
**Tests:** `test/hooks/check_tdd_progress_test.sh`

### Test 1: Exits 0 when stop_hook_active is true

**Given:**
- JSON input contains `{"stop_hook_active": true}`
- A `.tdd-progress.md` file may or may not exist

**When:**
- The hook script receives the JSON via stdin

**Then:**
- Exit code is 0
- No JSON output is produced (stdout is empty)

### Test 2: Exits 0 when no progress file exists

**Given:**
- JSON input with `stop_hook_active` absent or false
- No `.tdd-progress.md` file exists in the working directory

**When:**
- The hook script receives the JSON via stdin

**Then:**
- Exit code is 0
- No JSON output is produced

### Test 3: Exits 0 when no slices found in progress file

**Given:**
- JSON input with `stop_hook_active` absent or false
- `.tdd-progress.md` exists but contains no `## Slice` or `## Step` headers

**When:**
- The hook script receives the JSON via stdin

**Then:**
- Exit code is 0
- No JSON output is produced

### Test 4: Outputs block decision when slices remain incomplete

**Given:**
- JSON input with `stop_hook_active` absent or false
- `.tdd-progress.md` exists with 3 slice headers, only 1 has a terminal status

**When:**
- The hook script receives the JSON via stdin

**Then:**
- Exit code is 0
- Stdout contains valid JSON with `"decision": "block"`
- JSON `reason` field mentions "2 of 3 slices remaining"

### Test 5: Exits 0 with no output when all slices are terminal

**Given:**
- JSON input with `stop_hook_active` absent or false
- `.tdd-progress.md` exists with 2 slice headers, both have terminal status lines

**When:**
- The hook script receives the JSON via stdin

**Then:**
- Exit code is 0
- No JSON block output

### Edge Cases

**Test 6: Case-insensitive status matching**

**Given:**
- `.tdd-progress.md` with slice headers and `Status: DONE` (uppercase)

**When:**
- The hook processes the file

**Then:**
- The slice counts as terminal (case-insensitive match)

**Test 7: All terminal states recognized**

**Given:**
- `.tdd-progress.md` with 5 slices, each having one of: pass, done, complete, fail, skip

**When:**
- The hook processes the file

**Then:**
- All 5 are recognized as terminal, REMAINING is 0, exit 0 with no block output

**Test 8: Progress file exists but is empty**

**Given:**
- `.tdd-progress.md` exists but is empty (0 bytes)

**When:**
- The hook processes the file

**Then:**
- TOTAL_SLICES is 0, exit 0 (allow stop)

**Test 9: Missing stop_hook_active field in JSON**

**Given:**
- JSON input is `{}` (no stop_hook_active field)
- No `.tdd-progress.md` exists

**When:**
- The hook processes the input

**Then:**
- jq returns "null" for stop_hook_active, which is not "true", so processing continues
- No progress file means exit 0

### Acceptance Criteria
- [ ] 9 tests covering all 5 code paths plus 4 edge cases
- [ ] All tests use isolated temp directories (no side effects)
- [ ] Test helpers follow established patterns
- [ ] shellcheck passes on test file

### Phase Tracking

- **RED:** done
- **GREEN:** done
- **REFACTOR:** done

**Depends on:** none | **Blocks:** none

---

## Slice 2: auto-run-tests.sh — JSON Output Safety Fix

**Status:** done

**Source:** `hooks/auto-run-tests.sh`
**Tests:** `test/hooks/auto_run_tests_test.sh`

### Test 1: JSON output is valid when RESULT contains double quotes

**Given:**
- A `.sh` source file with a matching `_test.sh` test file
- bashunit is available
- The test runner output contains double-quote characters

**When:**
- The hook runs and captures test output

**Then:**
- The stdout is valid JSON (parseable by jq)
- The `systemMessage` field contains the test output with quotes preserved

### Test 2: JSON output is valid when RESULT contains newlines

**Given:**
- A `.sh` source file with a matching `_test.sh` test file
- bashunit is available
- The test runner output contains newline characters

**When:**
- The hook runs and captures test output

**Then:**
- The stdout is valid JSON (parseable by jq)

### Test 3: JSON output is valid when RESULT contains backslashes

**Given:**
- A `.sh` source file with a matching `_test.sh` test file
- bashunit is available
- The test runner output contains backslash characters

**When:**
- The hook runs and captures test output

**Then:**
- The stdout is valid JSON (parseable by jq)

### Test 4: JSON output is valid for "no matching test file" message

**Given:**
- A `.dart` source file with no matching test file

**When:**
- The hook runs

**Then:**
- Stdout is valid JSON (parseable by jq)
- `systemMessage` contains "No matching test file"

### Edge Cases

**Test 5: JSON output is valid for "bashunit not installed" message**

**Given:**
- A `.sh` source file
- bashunit is NOT available (not in PATH, no ./lib/bashunit)

**When:**
- The hook runs

**Then:**
- Stdout is valid JSON (parseable by jq)
- `systemMessage` contains "not installed"

**Test 6: Non-source file extension exits silently (no JSON)**

**Given:**
- A file extension that does not match any handler (e.g., `.txt`)

**When:**
- The hook runs

**Then:**
- Exit code is 0
- Stdout is empty (no JSON output, script exits early on line 9)

### Implementation Notes

Replace line 64 of `hooks/auto-run-tests.sh`:
```bash
echo "{\"systemMessage\": \"Auto-test: $RESULT\"}"
```
with:
```bash
jq -n --arg msg "Auto-test: $RESULT" '{"systemMessage": $msg}'
```

**Important:** The `test_existing_hooks_unmodified` test in `planner_bash_guard_test.sh` hardcodes an MD5 checksum for `auto-run-tests.sh`. After modifying line 64, this checksum must be updated in the GREEN phase.

### Acceptance Criteria
- [ ] All JSON output from auto-run-tests.sh passes `jq empty` validation
- [ ] Special characters (quotes, newlines, backslashes) are properly escaped
- [ ] Existing 6 tests continue to pass after the fix
- [ ] MD5 checksum in `planner_bash_guard_test.sh` updated
- [ ] shellcheck passes on the modified script

### Phase Tracking

- **RED:** done
- **GREEN:** done
- **REFACTOR:** done

**Depends on:** none | **Blocks:** Slice 3

---

## Slice 3: auto-run-tests.sh — FVM Detection and Dart/C++ Path Coverage

**Status:** done

**Source:** `hooks/auto-run-tests.sh`
**Tests:** `test/hooks/auto_run_tests_test.sh`

### Test 1: Dart file uses fvm flutter when .fvmrc exists and fvm command available

**Given:**
- A `.dart` source file with a matching `_test.dart` test file
- `.fvmrc` exists in the working directory
- A stub `fvm` script is available on PATH

**When:**
- The hook runs for the `.dart` file

**Then:**
- The hook invokes `fvm flutter test` (verified via stub output)
- Stdout contains valid JSON with `systemMessage`

### Test 2: Dart file falls back to plain flutter when .fvmrc present but fvm command missing

**Given:**
- A `.dart` source file with a matching `_test.dart` test file
- `.fvmrc` exists in the working directory
- `fvm` is NOT on PATH (command -v fvm fails)

**When:**
- The hook runs for the `.dart` file

**Then:**
- The hook invokes `flutter test` (not `fvm flutter test`) due to `&&` short-circuit on line 23
- Stdout contains valid JSON with `systemMessage`

### Test 3: Dart file uses plain flutter when .fvmrc is absent

**Given:**
- A `.dart` source file with a matching `_test.dart` test file
- No `.fvmrc` in the working directory

**When:**
- The hook runs for the `.dart` file

**Then:**
- The hook invokes `flutter test` (not `fvm flutter test`)
- Stdout contains valid JSON with `systemMessage`

### Test 4: Dart test file mapping (lib/ to test/)

**Given:**
- A dart source file at `lib/models/user.dart`
- A corresponding test file exists at `test/models/user_test.dart`

**When:**
- The hook runs for `lib/models/user.dart`

**Then:**
- The hook identifies `test/models/user_test.dart` as the test file
- Stdout contains valid JSON with `systemMessage`

### Test 5: Dart _test.dart file runs directly

**Given:**
- A dart test file at `test/models/user_test.dart`

**When:**
- The hook runs for `test/models/user_test.dart`

**Then:**
- The hook uses the file path directly as TEST_FILE
- Stdout contains valid JSON with `systemMessage`

### Test 6: C++ file with build directory triggers cmake build

**Given:**
- A `.cpp` file at `src/parser.cpp`
- A `build/` directory exists

**When:**
- The hook runs for the `.cpp` file

**Then:**
- Stdout contains valid JSON with `systemMessage`
- The output references cmake build output

### Test 7: C++ file without build directory reports error

**Given:**
- A `.cpp` file at `src/parser.cpp`
- No `build/` directory exists

**When:**
- The hook runs

**Then:**
- Stdout contains valid JSON with `systemMessage`
- `systemMessage` contains "No build directory found"

### Test 8: .hpp file handled as C++ by elif branch on line 32

**Given:**
- A `.hpp` file at `src/types.hpp`
- No `build/` directory exists

**When:**
- The hook runs for the `.hpp` file

**Then:**
- Line 9 source filter passes (`.hpp` is in the pattern)
- Line 32 C++ elif matches (`.hpp` IS included in `\.(cpp|cc|h|hpp)$`)
- `systemMessage` contains "No build directory found" (same as .cpp behavior)
- Note: Contrary to initial assumption, `.hpp` IS handled — it enters the C++ branch

### Edge Cases

**Test 9: Non-source file extension exits silently**

**Given:**
- A file path ending in `.md`, `.yaml`, `.json`, or `.txt`

**When:**
- The hook receives this file path

**Then:**
- Exit code is 0
- Stdout is empty (no JSON output)

**Test 10: Empty file path exits silently**

**Given:**
- JSON input where file_path resolves to empty string

**When:**
- The hook receives this input

**Then:**
- Exit code is 0
- Stdout is empty

### Acceptance Criteria
- [ ] FVM detection logic tested in three scenarios: fvmrc+fvm, fvmrc+no-fvm, no-fvmrc
- [ ] Dart test file mapping from lib/ to test/ verified
- [ ] C++ build directory detection tested in both cases
- [ ] .hpp handling documented (enters C++ branch via line 32)
- [ ] Non-source file pass-through verified
- [ ] All tests use isolated temp directories
- [ ] shellcheck passes on test file

### Phase Tracking

- **RED:** done
- **GREEN:** done
- **REFACTOR:** done

**Depends on:** Slice 2 | **Blocks:** none

---

## Slice 4: validate-tdd-order.sh — Edge Case Coverage

**Status:** done

**Source:** `hooks/validate-tdd-order.sh`
**Tests:** `test/hooks/validate_tdd_order_test.sh`

### Test 1: Allows test_-prefixed files (test_helper pattern)

**Given:**
- JSON input with file_path `test_helper.sh`

**When:**
- The hook processes the input

**Then:**
- Exit code is 0 (allowed — matches `test_.*\.(dart|cpp|cc|h|sh)$` on line 9)

### Test 2: Allows .hpp files in test directories

**Given:**
- JSON input with file_path `test/unit/test_fixture.hpp`

**When:**
- The hook processes the input

**Then:**
- Exit code is 0 (path matches `(^|/)test/` on line 9)

### Test 3: Blocks .hpp source files when no tests written

**Given:**
- JSON input with file_path `src/utils.hpp`
- No test files have been staged in git diff

**When:**
- The hook processes the input

**Then:**
- Exit code is 2 (blocked — `.hpp` matches source pattern on line 14, no tests found)

### Test 4: Empty file path passes through

**Given:**
- JSON input with empty file_path (`""`)

**When:**
- The hook processes the input

**Then:**
- Exit code is 0 (empty string does not match source extension pattern on line 14)

### Test 5: Handles git diff failure gracefully

**Given:**
- JSON input with file_path `hooks/my_script.sh`
- Working directory is NOT a git repository

**When:**
- The hook processes the input

**Then:**
- `git diff` fails silently (stderr suppressed by `2>/dev/null`)
- `grep -c` on empty input returns 0
- Exit code is 2 (blocked)
- stderr contains "BLOCKED"

### Test 6: .cc file treated as source — blocks without tests

**Given:**
- JSON input with file_path `src/parser.cc`
- No test files have been staged in git diff

**When:**
- The hook processes the input

**Then:**
- Exit code is 2 (blocked — `.cc` matches source pattern on line 14)

### Test 7: _test.cc file treated as test — allowed

**Given:**
- JSON input with file_path `src/parser_test.cc`

**When:**
- The hook processes the input

**Then:**
- Exit code is 0 (matches `_test\.(dart|cpp|cc|h|sh)$` on line 9)

### Test 8: _test.hpp OUTSIDE test/ — NOT recognized as test file (latent bug)

**Given:**
- JSON input with file_path `src/parser_test.hpp`
- No test files have been staged in git diff

**When:**
- The hook processes the input

**Then:**
- Line 9 regex `_test\.(dart|cpp|cc|h|sh)$` does NOT include `hpp` — no match
- Line 9 regex `test_.*\.(dart|cpp|cc|h|sh)$` does NOT include `hpp` — no match
- Path does not contain `/test/` — no match
- Falls through to line 14: `.hpp` IS a source file
- Exit code is 2 (blocked)
- Note: This is a latent bug — `_test.hpp` should arguably be treated as a test file, but the line 9 regex omits `hpp` from the `_test` pattern. Documenting, not fixing.

### Edge Cases

**Test 9: File in test/ subdirectory without _test suffix passes**

**Given:**
- JSON input with file_path `test/helpers/setup.sh`

**When:**
- The hook processes the input

**Then:**
- Exit code is 0 (path matches `(^|/)test/` pattern on line 9)

**Test 10: Malformed JSON input — graceful handling**

**Given:**
- Input is `"not json at all"` (not valid JSON)

**When:**
- The hook receives this on stdin

**Then:**
- `jq -r` returns empty/null for file_path
- Empty string does not match source pattern on line 14
- Exit code is 0 (passes through — no crash)

### Acceptance Criteria
- [ ] `test_`-prefixed file pattern verified
- [ ] `.hpp` handling tested in both test-directory and source contexts
- [ ] `.cc` file correctly treated as source (blocks) and `_test.cc` as test (allows)
- [ ] `_test.hpp` latent bug documented via test (not fixed)
- [ ] Empty path edge case covered
- [ ] Malformed JSON doesn't crash the script
- [ ] git failure scenario tested in isolated (non-git) directory
- [ ] All existing 9 tests still pass
- [ ] shellcheck passes on test file

### Phase Tracking

- **RED:** done
- **GREEN:** done
- **REFACTOR:** done

**Depends on:** none | **Blocks:** none

---

## Slice Overview

| # | Slice | New Tests | Dependencies |
|---|-------|-----------|-------------|
| 1 | check-tdd-progress.sh — Retroactive coverage | 9 | None |
| 2 | auto-run-tests.sh — JSON output safety fix | 6 | None |
| 3 | auto-run-tests.sh — FVM + dart/C++ path coverage | 10 | Slice 2 |
| 4 | validate-tdd-order.sh — Edge case coverage | 10 | None |

**Total new tests:** 35 | **Existing tests:** 67 | **Expected total:** 102

---

## Global Acceptance Criteria

- [ ] All 102 tests pass (67 existing + 35 new)
- [ ] `shellcheck -S warning` passes on all modified hook scripts and test files
- [ ] JSON output from `auto-run-tests.sh` passes `jq empty` for all possible `$RESULT` values
- [ ] No breaking changes to existing hook behavior
- [ ] MD5 checksum in `planner_bash_guard_test.sh` updated for changed `auto-run-tests.sh`
- [ ] `CHANGELOG.md` updated

---

## Status Vocabulary

| Status | Meaning |
|--------|---------|
| `pending` | Not yet started |
| `in-progress` | Currently being worked on |
| `done` | Completed successfully |
| `pass` | Test/verification passed |
| `fail` | Test/verification failed |
| `skip` | Intentionally skipped |
